import{_ as e,a as l,G as n,o as d}from"./chunks/framework.8Qnc-F5A.js";const O=JSON.parse('{"title":"什么是函数式编程","description":"","frontmatter":{"title":"什么是函数式编程","create":"2024-12-29T00:00:00.000Z","desc":"对比 FP 语言的特性"},"headers":[],"relativePath":"blog/fp.md","filePath":"blog/fp.md"}'),r={name:"blog/fp.md"};function a(s,t,c,i,g,x){return d(),l("div",null,t[0]||(t[0]=[n('<p>当下，尤其是在前端，函数式编程（FP）已成显学。然而，究竟什么是函数式编程？λ表达式、递归、不可变、惰性求值、Monad……什么特性能代表 FP？哪些特性是 FP 语言有而其他语言没有的？哪些特性是某些 FP 语言独有的，哪些特性是大部分 FP 语言共有的？</p><p>据我所知，最流行的 FP 语言有两类：以 Scheme 为代表的 Lisp、以 Haskell 为代表的 ML。再取 C 作为非 FP 语言的代表，JavaScript 为流行的语言的代表，在下表中对比其特性。O 为支持，空为不支持。我基本不会这些语言，可能有错误或列举不完整。</p><div class="table"><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">Scheme</th><th style="text-align:center;">Haskell</th><th style="text-align:center;">JavaScript</th><th style="text-align:center;">C</th></tr></thead><tbody><tr><td style="text-align:center;">函数一等公民</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td style="text-align:center;">闭包（λ表达式）</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">默认柯里化</td><td style="text-align:center;"></td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">可变参数</td><td style="text-align:center;">O</td><td style="text-align:center;">差强人意</td><td style="text-align:center;">O</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">词法作用域</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td></tr><tr><td style="text-align:center;">Let 表达式</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">尾递归优化</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">事实上没有</td><td style="text-align:center;">支持但不保证</td></tr><tr><td style="text-align:center;">垃圾回收</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">过程宏</td><td style="text-align:center;">O</td><td style="text-align:center;">扩展支持</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">自定义运算符</td><td style="text-align:center;">差强人意</td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">无副作用、惰性求值</td><td style="text-align:center;"></td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">模块</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">O</td><td style="text-align:center;">可以说没有</td></tr><tr><td style="text-align:center;">模式匹配</td><td style="text-align:center;">可以说没有</td><td style="text-align:center;">O</td><td style="text-align:center;">无法判断</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">静态类型</td><td style="text-align:center;"></td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;">O</td></tr><tr><td style="text-align:center;">ADT</td><td style="text-align:center;"></td><td style="text-align:center;">O</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">call/cc</td><td style="text-align:center;">O</td><td style="text-align:center;">可以说没有</td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table></div><p>综上所述，FP 语言共有的特性中，已经流行的有：闭包、可变参数、垃圾回收、模块。未流行的有：<strong>Let 表达式、尾递归优化 、过程宏、自定义运算符</strong>。</p><p>非常神奇啊！这些重要特性似乎和常见认知中的 FP 联系不很大。究其原因，Lisp 和 Haskell 是两个极端，动态类型与静态类型、严格求值与惰性求值，都是对立的。常见认知中的 FP 更接近 Haskell。不过，看看这些 FP 语言共有且未流行的特性，确实都是重要特性，希望能早日普及开来。</p>',5)]))}const p=e(r,[["render",a]]);export{O as __pageData,p as default};
