import{_ as e,a as r,o as t,l as a}from"./chunks/framework.B4KAFDZH.js";const m=JSON.parse('{"title":"编写「bf2wasm」","description":"","frontmatter":{"title":"编写「bf2wasm」","create":"2024-03-26T00:00:00.000Z","desc":"开发中用到的技术"},"headers":[],"relativePath":"blog/bf2wasm.md","filePath":"blog/bf2wasm.md"}'),o={name:"blog/bf2wasm.md"},s=a('<p>写了个好玩的东西，<a href="https://zeng-y-l.github.io/project/bf2wasm" target="_blank" rel="noreferrer">bf2wasm</a>（<a href="https://gitee.com/Zeng_YL/bf2wasm" target="_blank" rel="noreferrer">源码</a>），可以把 Brainfuck 编译到 WASM 并运行。用了一些有趣的技术，本文简述之。</p><h2>PureScript</h2><p><a href="https://www.purescript.org/" target="_blank" rel="noreferrer">PureScript</a> 是编译到 JavaScript 的 Haskell 方言。与 JavaScript 的交互十分简单，可以部分地使用，比 Haskell 容易上手。</p><p>它是严格求值的。受限于 JavaScript，它只有尾递归优化，没有尾调用优化，不过有一个库显式构造尾调用。<code>ST a</code> 和 <code>Effect a</code> Monad 都是简单的 <code>() =&gt; a</code>，直接使用或许会导致栈溢出。</p><p>它有一定的生态。有 <a href="https://pursuit.purescript.org/" target="_blank" rel="noreferrer">Pursuit</a>，可以统一地查看文档，还有类似 Hoogle 的搜索。</p><p>它没有 GADT 和 type family。</p><h2>WebAssembly</h2><p><a href="https://webassembly.org/" target="_blank" rel="noreferrer">WebAssembly</a> 是一种堆栈机指令格式。我使用 <a href="https://github.com/kritzcreek/purescript-wasm" target="_blank" rel="noreferrer">kritzcreek/purescript-wasm</a> 生成 WASM。</p><p>它功能较少，标准规范简洁清晰。略读标准后就可以轻松写出简单的代码。</p><p>它没有异步的功能，无法暂停执行或实现 continuation 之类。因此导入的函数都要是同步的。</p><h2>Web Worker</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noreferrer">Web Workers</a> 可以多线程运行 JavaScript 代码。代价是通信不便。</p><p>我原本打算用同步通信实现等待主线程的用户输入，但 <code>SharedArrayBuffer</code> 似乎对跨域有些要求，我就放弃了。</p>',13),p=[s];function c(l,n,_,i,f,b){return t(),r("div",null,p)}const d=e(o,[["render",c]]);export{m as __pageData,d as default};
